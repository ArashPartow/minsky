
\chapter{User defined functions}

\label{ExprTk}

{\em Much of this chapter is exerpted from \htmladdnormallink{exprtk's
read.txt file}{https://github.com/ArashPartow/exprtk/blob/master/readme.txt}}

\section{Introduction}

The \htmladdnormallink{C++ Mathematical Expression Toolkit Library
(ExprTk)}{https://www.partow.net/programming/exprtk/index.html}
is a simple to use, easy to integrate and extremely efficient run-time
mathematical expression parsing and evaluation engine. The parsing
engine supports numerous forms of functional and logic processing
semantics and is easily extensible.

With Minsky's user defined functions, expressions can refer to Minsky
variables accessible from the current scope (ie local Minsky variables
will hide global variables), and also parameters declared as part
of the function name. One can also call other user defined functions,
which is the only way a user defined function with more than 2 parameters
can be used. For 0-2 parameters, user defined functions can be wired
into a Minsky computation.

ExprTk identifiers (such as variable names and function names) consist
of alphanumeric characters plus '\_' and '.'. They must start with
a letter. Minsky is reserving the underscore and full stop to act
as an escape sequence, in order to refer to the full range of possible
Minsky variable identifiers, including all unicode characters. This
section will be updated once that feature is in place --- for now,
please avoid using those characters in identifiers.

\section{Capabilities}

The ExprTk expression evaluator supports the following fundamental
arithmetic operations, functions and processes:
\begin{description}
\item [{Types:}] Scalar, Vector, String
\item [{Basic operators:}] \verb'+, -, *, /, %, ^'
\item [{Assignment:}] \verb':=, +=, -=, *=, /=, %='
\item [{Equalities \& Inequalities:}] \verb'=, ==, <>, !=, <, <=, >, >='
\item [{Logic operators:}] and, mand, mor, nand, nor, not, or, shl, shr,
xnor, xor, true, false
\item [{Functions:}] abs, avg, ceil, clamp, equal, erf, erfc, exp, expm1,
floor, frac, log, log10, log1p, log2, logn, max, min, mul, ncdf, nequal,
root, round, roundn, sgn, sqrt, sum, swap, trunc
\item [{Trigonometry:}] acos, acosh, asin, asinh, atan, atanh, atan2, cos,
cosh, cot, csc, sec, sin, sinc, sinh, tan, tanh, hypot, rad2deg, deg2grad,
deg2rad, grad2deg
\item [{Control structures:}] if-then-else, ternary conditional, switch-case,
return-statement
\item [{Loop statements:}] while, for, repeat-until, break, continue
\item [{String processing:}] in, like, ilike, concatenation
\item [{Optimisations:}] constant-folding, simple strength reduction and
dead code elimination
\item [{Calculus:}] numerical integration and differentiation
\end{description}

\section{Example expressions}

The following is a short listing of infix format based mathematical
expressions that can be parsed and evaluated using the ExprTk library.
\begin{itemize}
\item \verb'sqrt(1 - (3 / x^2))' 
\item \verb'clamp(-1, sin(2 * pi * x) + cos(y / 2 * pi), +1)' 
\item \verb'sin(2.34e-3 * x)' 
\item \verb'if(((x[2] + 2) == 3) and ((y + 5) <= 9),1 + w, 2 / z)' 
\item \verb'inrange(-2,m,+2) == if(({-2 <= m} and [m <= +2]),1,0)' 
\item \verb'({1/1}*[1/2]+(1/3))-{1/4}^[1/5]+(1/6)-({1/7}+[1/8]*(1/9))' 
\item \verb'a * exp(2.2 / 3.3 * t) + c' 
\item \verb'z := x + sin(2.567 * pi / y)' 
\item \verb'u := 2.123 * {pi * z} / (w := x + cos(y / pi))' 
\item \verb'2x + 3y + 4z + 5w == 2 * x + 3 * y + 4 * z + 5 * w' 
\item \verb'3(x + y) / 2.9 + 1.234e+12 == 3 * (x + y) / 2.9 + 1.234e+12' 
\item \verb'(x + y)3.3 + 1 / 4.5 == [x + y] * 3.3 + 1 / 4.5' 
\item \verb'(x + y[i])z + 1.1 / 2.7 == (x + y[i]) * z + 1.1 / 2.7' 
\item \verb'(sin(x / pi) cos(2y) + 1) == (sin(x / pi) * cos(2 * y) + 1)' 
\item \verb'75x^17 + 25.1x^5 - 35x^4 - 15.2x^3 + 40x^2 - 15.3x + 1' 
\item \verb'(avg(x,y) <= x + y ? x - y : x * y) + 2.345 * pi / x' 
\item \verb'while (x <= 100) { x -= 1; }' 
\item \verb"x <= 'abc123' and (y in 'AString') or ('1x2y3z' != z)" 
\item \verb"((x + 'abc') like '*123*') or ('a123b' ilike y)" 
\item \verb'sgn(+1.2^3.4z / -5.6y) <= {-7.8^9 / -10.11x }' 
\end{itemize}

\section{Copyright notice}

Free use of the C++ Mathematical Expression Toolkit Library is permitted
under the guidelines and in accordance with the most current version
of the \htmladdnormallink{MIT License}{http://www.opensource.org/licenses/MIT}

\section{Built-in operations \& functions}

\subsection{Arithmetic \& Assignment Operators}

\begin{tabular}{|c|p{0.8\textwidth}|}
\hline 
OPERATOR  & DEFINITION \tabularnewline
\hline 
\verb'+' & Addition between x and y. (eg: \verb'x + y'\tabularnewline
 & Subtraction between x and y. (eg: \verb'x - y'\tabularnewline
 & Multiplication between x and y. (eg: \verb'x * y'\tabularnewline
 & Division between x and y. (eg: \verb'x / y'\tabularnewline
\parbox[t]{}{\verb'%'\& Modulus of x with respect to y. (eg: \verb'x % y')\\
 } & $x^{y}$. (eg: \verb'x ^ y'\tabularnewline
: & Assign the value of x to y. Where y is either a variable or vector
type. (eg: \verb'y := x'\tabularnewline
+ & Increment x by the value of the expression on the right hand side.
Where x is either a variable or vector type. (eg: \verb'x += abs(y - z)'\tabularnewline
- & Decrement x by the value of the expression on the right hand side.
Where x is either a variable or vector type. (eg: \verb'x[i] -= abs(y + z)'\tabularnewline
{*} & Assign the multiplication of x by the value of the expression on the
righthand side to x. Where x is either a variable or vector type.
(eg: \verb'x *= abs(y / z)'\tabularnewline
/ & Assign the division of x by the value of the expression on the right-hand
side to x. Where x is either a variable or vector type. (eg: \verb'x[i + j] /= abs(y * z)'\tabularnewline
\parbox[t]{}{\verb'%='\& Assign x modulo the value of the expression on the right
hand side to x. Where x is either a variable or vector type. (eg:
\verb'x[2] %= y ^ 2')\\
} & \tabularnewline
\end{tabular}

\subsection{Equalities \& Inequalities}

\begin{tabular}{|c|p{0.8\textwidth}|}
\hline 
OPERATOR  & DEFINITION\tabularnewline
\hline 
\verb'==' or  & True only if x is strictly equal to y. (eg: \verb'x == y'\tabularnewline
\verb'<>' or  & True only if x does not equal y. (eg: \verb'x <> y' or x != \tabularnewline
 & True only if x is less than y. (eg: \verb'x < y'\tabularnewline
\textless{} & True only if x is less than or equal to y. (eg: \verb'x <= y'\tabularnewline
 & True only if x is greater than y. (eg: x \textgreater{} \tabularnewline
\textgreater{} & True only if x greater than or equal to y. (eg: \verb'x >= y'\tabularnewline
\hline 
\end{tabular}

\subsection{Boolean Operations}

\begin{tabular}{|c|p{0.8\textwidth}|}
\hline 
OPERATOR & DEFINITION\tabularnewline
\hline 
tru & True state or any value other than zero (typically 1).\tabularnewline
fals & False state, value of exactly zero.\tabularnewline
an & Logical AND, True only if x and y are both true. (eg: \verb'x and y'\tabularnewline
man & Multi-input logical AND, True only if all inputs are true. Left to
right short-circuiting of expressions. (eg: \verb'mand(x > y, z < w, u or v, w and x)'\tabularnewline
mo & Multi-input logical OR, True if at least one of the inputs are true.
Left to right short-circuiting of expressions. (eg: \verb'mor(x > y, z < w, u or v, w and x)'\tabularnewline
nan & Logical NAND, True only if either x or y is false. (eg: \verb'x nand y'\tabularnewline
no & Logical NOR, True only if the result of x or y is false (eg: \verb'x nor y'\tabularnewline
no & Logical NOT, Negate the logical sense of the input. (eg: \verb'not(x and y) == x nand y'\tabularnewline
o & Logical OR, True if either x or y is true. (eg: \verb'x or y')\tabularnewline
xo & Logical XOR, True only if the logical states of x and y differ. (eg:
\verb'x xor y'\tabularnewline
xno & Logical XNOR, True iff the biconditional of x and y is satisfied.
(eg: \verb'x xnor y'\tabularnewline
 & '\tabularnewline
 & Similar to OR but with left to right expression short circuiting optimisation.
(eg: \verb'(x | y) == (y or x)'\tabularnewline
\hline 
\end{tabular}

\subsection{General Purpose Functions}

\begin{tabular}{|c|p{0.8\textwidth}|}
\hline 
FUNCTION  & DEFINITION\tabularnewline
\hline 
ab & Absolute value of x. (eg: \verb'abs(x)'\tabularnewline
av & Average of all the inputs. (eg: \verb'avg(x,y,z,w,u,v) == (x + y + z + w + u + v) / 6'\tabularnewline
cei & Smallest integer that is greater than or equal to x.\tabularnewline
clam & Clamp x in range between r0 and r1, where r0 \textless{} r1. (eg:
\verb'clamp(r0,x,r1)'\tabularnewline
equa & Equality test between x and y using normalised epsilon\tabularnewline
er & Error function of x. (eg: \verb'erf(x)'\tabularnewline
erf & Complimentary error function of x. (eg: \verb'erfc(x)'\tabularnewline
ex & $e^{x}$ (eg: \verb'exp(x)'\tabularnewline
expm & $e^{x-1}$ where $x$ is very small. (eg: \verb'expm1(x)'\tabularnewline
floo & Largest integer that is less than or equal to x. (eg: \verb'floor(x)'\tabularnewline
fra & Fractional portion of x. (eg: \verb'frac(x)'\tabularnewline
hypo & $\sqrt{x^{2}+y^{2}}$ (eg: \verb'hypot(x,y) = sqrt(x*x + y*y)'\tabularnewline
iclam & Inverse-clamp x outside of the range r0 and r1. Where r0 \textless{}
r1. If x is within the range it will snap to the closest bound. (eg:
\verb'iclamp(r0,x,r1)' $=\left\{ \begin{array}{ccc}
r0 & \mathrm{if} & x\le r0\\
x & \mathrm{if} & r0\le x\le r1\\
r1 & \mathrm{if} & x\ge r1
\end{array}\right.$ )\tabularnewline
inrang & In-range returns 'true' when $x$ is within the range $[r_{0},r_{1}]$.
Where $r_{0}<r_{1}$. (eg: \verb'inrange(r0,x,r1)'\tabularnewline
lo & Natural logarithm $\ln x$. (eg: \verb'log(x)'\tabularnewline
log1 & $\log_{10}x$. (eg: \verb'log10(x)'\tabularnewline
log1 & $\ln(1+x)$, where $x$ is very small. (eg: \verb'log1p(x)'\tabularnewline
log & $\log_{2}x$. (eg: \verb'log2(x)'\tabularnewline
log & $\log_{n}x$, where $n$ is a positive integer. (eg: \verb'logn(x,8)'\tabularnewline
ma & Largest value of all the inputs. (eg: \verb'max(x,y,z,w,u,v)'\tabularnewline
mi & Smallest value of all the inputs. (eg: \verb'min(x,y,z,w,u)'\tabularnewline
mu & Product of all the inputs. (eg: \verb'mul(x,y,z,w,u,v,t) == (x * y * z * w * u * v * t)')\tabularnewline
ncd & Normal cumulative distribution function. (eg: \verb'ncdf(x)'\tabularnewline
nequa & Not-equal test between $x$ and $y$ using normalised epsilon\tabularnewline
po & $x^{y}$. (eg: \verb'pow(x,y) == x ^ y'\tabularnewline
roo & $\sqrt[n]{x}$, where $n$ is a positive integer. (eg: \verb'root(x,3) == x^(1/3)'\tabularnewline
roun & Round $x$ to the nearest integer. (eg: \verb'round(x)'\tabularnewline
round & Round $x$ to $n$ decimal places (eg: \verb'roundn(x,3)') where
$n>0$ is an integer. (eg: roundn(1.2345678,4) == 1.234\tabularnewline
sg & Sign of $x$, $-1$ where $x<0$, +1 where $x>0$, else zero. (eg:
\verb'sgn(x)'\tabularnewline
sqr & $\sqrt{x}$, where $x>=0$. (eg: \verb'sqrt(x)'\tabularnewline
su & Sum of all the inputs. (eg: \verb'sum(x,y,z,w,u,v,t) == (x + y + z + w + u + v + t)'\tabularnewline
swa & \tabularnewline
\textless = & Swap the values of the variables x and y and return the current value
of y. (eg: \verb'swap(x,y)' or x \textless =\textgreater{} \tabularnewline
trun & Integer portion of x. (eg: \verb'trunc(x)'\tabularnewline
\hline 
\end{tabular}

\subsection{Trigonometry Functions}

\begin{tabular}{|c|p{0.8\textwidth}|}
\hline 
FUNCTION  & DEFINITION\tabularnewline
\hline 
aco & Arc cosine of x expressed in radians. Interval $[-1,+1]$ (eg: \verb'acos(x)'\tabularnewline
acos & Inverse hyperbolic cosine of x expressed in radians. (eg: \verb'acosh(x)'\tabularnewline
asi & Arc sine of x expressed in radians. Interval $[-1,+1]$ (eg: \verb'asin(x)'\tabularnewline
asin & Inverse hyperbolic sine of x expressed in radians. (eg: \verb'asinh(x)'\tabularnewline
ata & Arc tangent of x expressed in radians. Interval $[-1,+1]$ (eg: \verb'atan(x)'\tabularnewline
atan & Arc tangent of $(x/y)$ expressed in radians. $[-\pi,+\pi]$ (eg:
\verb'atan2(x,y)'\tabularnewline
atan & Inverse hyperbolic tangent of $x$ expressed in radians. (eg: \verb'atanh(x)'\tabularnewline
co & Cosine of $x$. (eg: \verb'cos(x)'\tabularnewline
cos & Hyperbolic cosine of $x$. (eg: \verb'cosh(x)'\tabularnewline
co & Cotangent of $x$. (eg: \verb'cot(x)'\tabularnewline
cs & Cosecant of $x$. (eg: \verb'csc(x)'\tabularnewline
se & Secant of $x$. (eg: \verb'sec(x)'\tabularnewline
si & Sine of $x$. (eg: \verb'sin(x)'\tabularnewline
sin & Sine cardinal of $x$. (eg: \verb'sinc(x)'\tabularnewline
sin & Hyperbolic sine of $x$. (eg: \verb'sinh(x)'\tabularnewline
ta & Tangent of $x$. (eg: \verb'tan(x)'\tabularnewline
tan & Hyperbolic tangent of $x$. (eg: \verb'tanh(x)'\tabularnewline
deg2ra & Convert $x$ from degrees to radians. (eg: \verb'deg2rad(x)'\tabularnewline
deg2gra & Convert $x$ from degrees to gradians. (eg: \verb'deg2grad(x)'\tabularnewline
rad2de & Convert $x$ from radians to degrees. (eg: \verb'rad2deg(x)'\tabularnewline
grad2de & Convert $x$ from gradians to degrees. (eg: \verb'grad2deg(x)'\tabularnewline
\hline 
\end{tabular}

\subsection{String Processing}

\begin{tabular}{|c|p{0.8\textwidth}|}
\hline 
FUNCTION & DEFINITION\tabularnewline
\verb'=' , \verb'==', \verb'!=', \verb'<>', \verb'<=', \verb'>=',
\verb'<' ,  & All common equality/inequality operators are applicable to strings
and are applied in a case sensitive manner. In the following example
x, y and z are of type string. (eg: \verb"not((x <= 'AbC') and ('1x2y3z' <> y)) or (z == x)"\tabularnewline
i & True only if $x$ is a substring of $y$. (eg: \verb'x in y' or 'abc'
in 'abcdefgh\tabularnewline
lik & True only if the string x matches the pattern y. Available wildcard
characters are `{*}' and `?' denoting zero or more and zero or one
matches respectively. (eg: \verb'x like y' or 'abcdefgh' like 'a?d{*}h\tabularnewline
ilik & True only if the string x matches the pattern y in a case insensitive
manner. Available wildcard characters are '{*}' and '?' denoting zero
or more and zero or one matches respectively. (eg: \verb'x ilike y'
or 'a1B2c3D4e5F6g7H' ilike 'a?d{*}h\tabularnewline
{[}r0:r1 & The closed interval $[r0,r1]$ of the specified string. eg: Given
a string x with a value of 'abcdefgh' then: 
\begin{enumerate}
\item \verb"x[1:4] == 'bcde'" 
\item \verb"x[ :5] == x[:10 / 2] == 'abcdef'" 
\item \verb"x[2 + 1: ] == x[3:] =='defgh'" 
\item \verb"x[ : ] == x[:] == 'abcdefgh'" 
\item \verb"x[4/2:3+2] == x[2:5] == 'cdef'" 
\end{enumerate}
Note: Both r0 and r1 are assumed to be integers, where r0 \textless =
r1. They may also be the result of an expression, in the event they
have fractional components truncation will be performed. (eg: $1.67\rightarrow1$)\tabularnewline
\hline 
%begin{latexonly}
 & \tabularnewline
\end{tabular}

\begin{tabular}{|c|p{0.8\textwidth}|}
\hline 
FUNCTION & DEFINITION\tabularnewline
\hline 
%end{latexonly}
: & Assign the value of x to y. Where y is a mutable string or string
range and x is either a string or a string range. eg: 
\begin{enumerate}
\item \verb'y := x' 
\item \verb"y := 'abc'" 
\item \verb'y := x[:i + j]' 
\item \verb"y := '0123456789'[2:7]" 
\item \verb"y := '0123456789'[2i + 1:7]" 
\item \verb"y := (x := '0123456789'[2:7])" 
\item \verb"y[i:j] := x" 
\item \verb"y[i:j] := (x + 'abcdefg'[8 / 4:5])[m:n]" 
\end{enumerate}
Note: For options 7 and 8 the shorter of the two ranges will denote
the number characters that are to be copied.\tabularnewline
 & Concatenation of x and y. Where x and y are strings or string ranges.
eg 
\begin{enumerate}
\item \verb"x + y" 
\item \verb"x + 'abc'" 
\item \verb"x + y[:i + j]" 
\item \verb"x[i:j] + y[2:3] + '0123456789'[2:7]" 
\item \verb"'abc' + x + y" 
\item \verb"'abc' + '1234567'" 
\item \verb"(x + 'a1B2c3D4' + y)[i:2j]" 
\end{enumerate}
\tabularnewline
+ & Append to x the value of y. Where x is a mutable string and y is either
a string or a string range. eg: 
\begin{enumerate}
\item \verb"x += y" 
\item \verb"x += 'abc'" 
\item \verb"x += y[:i + j] + 'abc'" 
\item \verb"x += '0123456789'[2:7]" 
\end{enumerate}
\tabularnewline
\textless = & Swap the values of x and y. Where x and y are mutable strings. (eg:
\verb'x <=> y'\tabularnewline
\hline 
%begin{latexonly}
 & \tabularnewline
\end{tabular}

\begin{tabular}{|c|p{0.8\textwidth}|}
\hline 
FUNCTION & DEFINITION\tabularnewline
\hline 
%end{latexonly}
{[} & The string size operator returns the size of the string being actioned.
eg: 
\begin{enumerate}
\item \verb"'abc'[] == 3" 
\item \verb"var max_str_length := max(s0[],s1[],s2[],s3[]" 
\item \verb"('abc' + 'xyz')[] == 6" 
\item \verb"(('abc' + 'xyz')[1:4])[] == 4" 
\end{enumerate}
\tabularnewline
\hline 
\end{tabular}

\subsection{Control Structures}

\begin{tabular}{|c|p{0.8\textwidth}|}
\hline 
STRUCTURE  & DEFINITION\tabularnewline
i & If x is true then return y else return z.eg: 
\begin{enumerate}
\item \verb"if (x, y, z)" 
\item \verb"if ((x + 1) > 2y, z + 1, w / v)" 
\item \verb"if (x > y) z;" 
\item \verb"if (x <= 2*y) { z + w };" 
\end{enumerate}
\tabularnewline
if-els & The if-else/else-if statement. Subject to the condition branch the
statement will return either the value of the consequent or the alternative
branch. eg: 
\begin{enumerate}
\item \verb"if (x > y) z; else w;" 
\item \verb"if (x > y) z; else if (w != u) v;" 
\item \verb"if (x < y) { z; w + 1; } else u;" 
\item 
\end{enumerate}
\begin{verbatim}
if ((x != y) and (z > w))
{   
  y := sin(x) / u;
  z := w + 1;     
}                  
else if (x > (z + 1))
{                    
  w := abs (x - y) + z;
  u := (x + 1) > 2y ? 2u : 3u;
}
\end{verbatim}
\tabularnewline
switc & The first true case condition that is encountered will determine the
result of the switch. If none of the case conditions hold true, the
default action is assumed as the final return value. This is sometimes
also known as a multi-way branch mechanism. eg: 
\begin{verbatim}
switch                                                 
{                                                      
  case x > (y + z) : 2 * x / abs(y - z);               
  case x < 3       : sin(x + y);                       
  default          : 1 + x;                            
}            
\end{verbatim}
\tabularnewline
whil & The structure will repeatedly evaluate the internal statement(s) 'while'
the condition is true. The final statement in the final iteration
will be used as the return value of the loop. eg: 
\begin{verbatim}
while ((x -= 1) > 0)                                   
{                                                      
  y := x + z;                                          
  w := u + y;                                          
}               
\end{verbatim}
\tabularnewline
\hline 
%begin{latexonly}
 & \tabularnewline
\end{tabular}

\begin{tabular}{|c|p{0.8\textwidth}|}
\hline 
FUNCTION & DEFINITION\tabularnewline
\hline 
%end{latexonly}
repeat/unti & The structure will repeatedly evaluate the internal statement(s) 'until'
the condition is true. The final statement in the final iteration
will be used as the return value of the loop. eg: 
\begin{verbatim}
repeat                                               
  y := x + z;                                        
  w := u + y;                                        
until ((x += 1) > 100)                               
\end{verbatim}
\tabularnewline
fo & The structure will repeatedly evaluate the internal statement(s) while
the condition is true. On each loop iteration, an 'incrementing' expression
is evaluated. The conditional is mandatory whereas the initialiser
and incrementing expressions are optional. eg: 
\begin{verbatim}
for (var x := 0; (x < n) and (x != y); x += 1)        
{                                                     
  y := y + x / 2 - z;                                 
  w := u + y;                                         
}            
\end{verbatim}
\tabularnewline
break/break{[} & Break terminates the execution of the nearest enclosed loop, allowing
for the execution to continue on external to the loop. The default
break statement will set the return value of the loop to NaN, where
as the return based form will set the value to that of the break expression.
eg: 
\begin{verbatim}
while ((i += 1) < 10)                                   
{                                                       
  if (i < 5)                                            
    j -= i + 2;                                         
  else if (i % 2 == 0)                                  
    break;                                              
  else                                                  
    break[2i + 3];                                      
}            
\end{verbatim}
\tabularnewline
continu & Continue results in the remaining portion of the nearest enclosing
loop body to be skipped. eg: 
\begin{verbatim}
for (var i := 0; i < 10; i += 1)  
{                                 
  if (i < 5)                      
    continue;                     
  j -= i + 2;                     
}            
\end{verbatim}
\tabularnewline
\hline 
%begin{latexonly}
 & \tabularnewline
\end{tabular}

\begin{tabular}{|c|p{0.8\textwidth}|}
\hline 
FUNCTION & DEFINITION\tabularnewline
\hline 
%end{latexonly}
retur & Return immediately from within the current expression. With the option
of passing back a variable number of values (scalar, vector or string).
eg: 
\begin{enumerate}
\item \verb"return [1]; " 
\item \verb"return [x, 'abx'];" 
\item \verb"return [x, x + y,'abx'];" 
\item \verb"return [];" 
\item 
\end{enumerate}
\begin{verbatim}
if (x < y)                                       
    return [x, x - y, 'result-set1', 123.456];      
   else                                             
    return [y, x + y, 'result-set2'];               
\end{verbatim}
\tabularnewline
? & Ternary conditional statement, similar to that of the above denoted
if-statement. eg: 
\begin{enumerate}
\item \verb"x ? y : z" 
\item \verb"x + 1 > 2y ? z + 1 : (w / v)" 
\item \verb"min(x,y) > z ? (x < y + 1) ? x : y : (w * v)" 
\end{enumerate}
\tabularnewline
 & Evaluate each sub-expression, then return as the result the value
of the last sub-expression. This is sometimes known as multiple sequence
point evaluation. eg: 
\begin{verbatim}
~(i := x + 1, j := y / z, k := sin(w/u)) == (sin(w/u)))
~{i := x + 1; j := y / z; k := sin(w/u)} == (sin(w/u)))
\end{verbatim}
\tabularnewline
{[}{*} & Evaluate any consequent for which its case statement is true. The
return value will be either zero or the result of the last consequent
to have been evaluated. eg: 
\begin{verbatim}
[*]                                                     
{                                                       
  case (x + 1) > (y - 2)    : x := z / 2 + sin(y / pi); 
  case (x + 2) < abs(y + 3) : w / 4 + min(5y,9);        
  case (x + 3) == (y * 4)   : y := abs(z / 6) + 7y;     
}              
\end{verbatim}
\tabularnewline
{[} & The vector size operator returns the size of the vector being actioned.
eg: 
\begin{enumerate}
\item \verb"v[]" 
\item \verb"max_size := max(v0[],v1[],v2[],v3[])" 
\end{enumerate}
\tabularnewline
\hline 
\end{tabular}

Note: In the tables above, the symbols x, y, z, w, u and v where appropriate
may represent any of one the following:
\begin{enumerate}
\item Literal numeric/string value 
\item A variable 
\item A vector element 
\item A vector 
\item A string 
\item An expression comprised of {[}1{]}, {[}2{]} or {[}3{]} (eg: \verb'2 + x /vec[3])' 
\end{enumerate}

\section{Fundamental types}

ExprTk supports three fundamental types which can be used freely in
expressions. The types are as follows:
\begin{description}
\item [{Scalar Type}] The scalar type is a singular numeric value. The
underlying type is that used to specialise the ExprTk components (float,
double, long double, MPFR et al).
\item [{Vector Type}] The vector type is a fixed size sequence of contiguous
scalar values. A vector can be indexed resulting in a scalar value.
Operations between a vector and scalar will result in a vector with
a size equal to that of the original vector, whereas operations between
vectors will result in a vector of size equal to that of the smaller
of the two. In both mentioned cases, the operations will occur element-wise.
\item [{String Type}] The string type is a variable length sequence of
8-bit chars. Strings can be assigned and concatenated to one another,
they can also be manipulated via sub-ranges using the range definition
syntax. Strings however can not interact with scalar or vector types.
\end{description}
}
